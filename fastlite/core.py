"""Source code for fastlite"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/00_core.ipynb.

# %% auto 0
__all__ = ['all_dcs', 'create_mod', 'get_typ', 'diagram']

# %% ../nbs/00_core.ipynb
from dataclasses import dataclass, field, make_dataclass, fields, Field, is_dataclass, MISSING
from typing import Any,Union,Optional, get_args
from enum import Enum
from inspect import get_annotations

from fastcore.utils import *
from fastcore.xml import highlight
from fastcore.xtras import hl_md, dataclass_src
from apswutils.db import *
from apswutils.utils import rows_from_file,TypeTracker,Format
import types

try: from graphviz import Source
except ImportError: pass

# %% ../nbs/00_core.ipynb
class _Getter:
    "Abstract class with dynamic attributes providing access to DB objects"
    def __init__(self, db): self.db = db
    # NB: Define `__dir__` in subclass to get list of objects
    def __repr__(self): return ", ".join(dir(self))
    def __contains__(self, s): return (s if isinstance(s,str) else s.name) in dir(self)
    def __iter__(self): return iter(self[dir(self)])
    def __getitem__(self, idxs):
        if isinstance(idxs,str): return self.db.table(idxs)
        return [self.db.table(o) for o in idxs]
    def __getattr__(self, k):
        if k[0]=='_': raise AttributeError
        return self.db[k]

class _TablesGetter(_Getter):
    def __dir__(self): return [o for o in self.db.table_names() if not o.startswith('sqlite_')]

@patch(as_prop=True)
def t(self:Database): return _TablesGetter(self)

# %% ../nbs/00_core.ipynb
class _Col:
    def __init__(self, t, c): self.t,self.c = t,c
    def __str__(self):  return f'"{self.t}"."{self.c}"'
    def __repr__(self):  return self.c
    def __iter__(self): return iter(self.c)

class _ColsGetter:
    def __init__(self, tbl): self.tbl = tbl
    def __dir__(self): return map(repr, self())
    def __call__(self): return [_Col(self.tbl.name,o.name) for o in self.tbl.columns]
    def __contains__(self, s): return (s if isinstance(s,str) else s.c) in self.tbl.columns_dict
    def __repr__(self): return ", ".join(dir(self))

    def __getattr__(self, k):
        if k[0]=='_': raise AttributeError
        return _Col(self.tbl.name, k)

@patch(as_prop=True)
def c(self:Table): return _ColsGetter(self)

@patch(as_prop=True)
def c(self:View): return _ColsGetter(self)

# %% ../nbs/00_core.ipynb
@patch
def __str__(self:Table): return f'"{self.name}"'

@patch
def __str__(self:View): return f'"{self.name}"'

# %% ../nbs/00_core.ipynb
@patch
def q(self:Database, sql: str, params=None):
    return list(self.query(sql, params=params))

# %% ../nbs/00_core.ipynb
def _get_flds(tbl): 
    return [(k, v|None, field(default=tbl.default_values.get(k,None)))
            for k,v in tbl.columns_dict.items()]

def _dataclass(self:Table, store=True, suf='')->type:
    "Create a `dataclass` with the types and defaults of this table"
    res = make_dataclass(self.name.title()+suf, _get_flds(self))
    flexiclass(res)
    if store: self.cls = res
    return res

Table.dataclass = _dataclass

# %% ../nbs/00_core.ipynb
def all_dcs(db, with_views=False, store=True, suf=''):
    "dataclasses for all objects in `db`"
    return [o.dataclass(store=store, suf=suf) for o in list(db.t) + (db.views if with_views else [])]

# %% ../nbs/00_core.ipynb
def create_mod(db, mod_fn, with_views=False, store=True, suf=''):
    "Create module for dataclasses for `db`"
    mod_fn = str(mod_fn)
    if not mod_fn.endswith('.py'): mod_fn+='.py'
    with open(mod_fn, 'w') as f:
        print('from dataclasses import dataclass', file=f)
        for o in all_dcs(db, with_views, store=store, suf=suf): print(dataclass_src(o), file=f)

# %% ../nbs/00_core.ipynb
@patch
def __call__(
    self:(Table|View),
    where:str|None=None,  # SQL where fragment to use, for example `id > ?`
    where_args: Iterable|dict|NoneType=None, # Parameters to use with `where`; iterable for `id>?`, or dict for `id>:id`
    order_by: str|None=None, # Column or fragment of SQL to order by
    limit:int|None=None, # Number of rows to limit to
    offset:int|None=None, # SQL offset
    select:str = "*", # Comma-separated list of columns to select
    with_pk:bool=False, # Return tuple of (pk,row)?
    as_cls:bool=True, # Convert returned dict to stored dataclass?
    xtra:dict|None=None, # Extra constraints
    fetchone:bool=False, # Only fetch one result
    **kwargs)->list:
    "Shortcut for `rows_where` or `pks_and_rows_where`, depending on `with_pk`"
    f = getattr(self, 'pks_and_rows_where' if with_pk else 'rows_where')
    if not xtra: xtra = getattr(self, 'xtra_id', {})
    if xtra:
        xw = ' and '.join(f"[{k}] = {v!r}" for k,v in xtra.items())
        where = f'{xw} and {where}' if where else xw
    res = f(where=where, where_args=where_args, order_by=order_by, limit=limit, offset=offset, select=select, **kwargs)
    if as_cls and hasattr(self,'cls'):
        if with_pk: res = ((k,self.cls(**v)) for k,v in res)
        else: res = (self.cls(**o) for o in res)
    return next(res) if fetchone else list(res)

# %% ../nbs/00_core.ipynb
@patch
def fetchone(
    self:(Table|View),
    where:str|None=None,  # SQL where fragment to use, for example `id > ?`
    where_args: Iterable|dict|NoneType=None, # Parameters to use with `where`; iterable for `id>?`, or dict for `id>:id`
    select:str = "*", # Comma-separated list of columns to select
    as_cls:bool=True, # Convert returned dict to stored dataclass?
    xtra:dict|None=None, # Extra constraints
    **kwargs)->list:
    "Shortcut for `__call__` that returns one item"
    return self(where=where, where_args=where_args, select=select, as_cls=as_cls, xtra=xtra, fetchone=True)

# %% ../nbs/00_core.ipynb
@patch
def set_classes(self:Database, glb):
    "Add set all table dataclasses using types in namespace `glb`"
    for tbl in self.t: tbl.cls = glb[tbl.name.title()]

# %% ../nbs/00_core.ipynb
@patch
def get_tables(self:Database, glb):
    "Add objects for all table objects to namespace `glb`"
    for tbl in self.t: glb[tbl.name.lower()+'s'] = tbl

# %% ../nbs/00_core.ipynb
class _ViewsGetter(_Getter):
    def __dir__(self): return self.db.view_names()

@patch(as_prop=True)
def v(self:Database): return _ViewsGetter(self)

# %% ../nbs/00_core.ipynb
def _parse_typ(t): return t if not (_args:= get_args(t)) else first(_args, bool)  

# %% ../nbs/00_core.ipynb
def _is_enum(o): return isinstance(o, type) and issubclass(o, Enum)
def _enum_types(e): return {type(v.value) for v in e}

def get_typ(t):
    "Get the underlying type."
    t = _parse_typ(t) # incase Union[Enum,None]
    if _is_enum(t) and len(types:=_enum_types(t)) == 1: return first(types)
    return t

# %% ../nbs/00_core.ipynb
@patch
def create(
    self: Database,
    cls=None,  # Dataclass to create table from
    name=None,  # Name of table to create
    pk='id',  # Column(s) to use as a primary key
    foreign_keys=None,  # Foreign key definitions
    defaults=None,  # Database table defaults
    column_order=None,  # Which columns should come first
    not_null=None,  # Columns that should be created as ``NOT NULL``
    hash_id=None,  # Column to be used as a primary key using hash
    hash_id_columns=None,  # Columns used when calculating hash
    extracts=None,  # Columns to be extracted during inserts
    if_not_exists=False,  # Use `CREATE TABLE IF NOT EXISTS`
    replace=False,  # Drop and replace table if it already exists
    ignore=True,  # Silently do nothing if table already exists
    transform=False,  # If table exists transform it to fit schema
    strict=False,  # Apply STRICT mode to table
):
    "Create table from `cls`, default name to snake-case version of class name"
    flexiclass(cls)
    if name is None: name = camel2snake(cls.__name__)
    typs = {o.name: get_typ(o.type) for o in fields(cls)}
    res = self.create_table(
        name, typs, defaults=defaults,
        pk=pk, foreign_keys=foreign_keys, column_order=column_order, not_null=not_null,
        hash_id=hash_id, hash_id_columns=hash_id_columns, extracts=extracts, transform=transform,
        if_not_exists=if_not_exists, replace=replace, ignore=ignore, strict=strict)
    res.cls = cls
    return res

# %% ../nbs/00_core.ipynb
@patch
def import_file(self:Database, table_name, file, format=None, pk=None, alter=False):
    "Import path or handle `file` to new table `table_name`"
    if isinstance(file, str): file = file.encode()
    if isinstance(file, bytes): file = io.BytesIO(file)
    with maybe_open(file) as fp: rows, format_used = rows_from_file(fp, format=format)
    tracker = TypeTracker()
    rows = tracker.wrap(rows)
    tbl = self[table_name]
    tbl.insert_all(rows, alter=alter)
    tbl.transform(types=tracker.types)
    if pk: tbl.transform(pk=pk)
    return tbl

# %% ../nbs/00_core.ipynb
def _edge(tbl):
    return "\n".join(f"{fk.table}:{fk.column} -> {fk.other_table}:{fk.other_column};"
                     for fk in tbl.foreign_keys)

def _row(col):
    xtra = " ðŸ”‘" if col.is_pk else ""
    bg = ' bgcolor="#ffebcd"' if col.is_pk else ""
    return f'    <tr><td port="{col.name}"{bg}>{col.name}{xtra}</td></tr>'

def _tnode(tbl):
    rows = "\n".join(_row(o) for o in tbl.columns)
    res = f"""<table cellborder="1" cellspacing="0">
    <tr><td bgcolor="lightgray">{tbl.name}</td></tr>
{rows}
  </table>"""
    return f"{tbl.name} [label=<{res}>];\n"

# %% ../nbs/00_core.ipynb
def diagram(tbls, ratio=0.7, size="10", neato=False, render=True):
    layout = "\nlayout=neato;\noverlap=prism;\noverlap_scaling=0.5;""" if neato else ""
    edges  = "\n".join(map(_edge,  tbls))
    tnodes = "\n".join(map(_tnode, tbls))
    
    res = f"""digraph G {{
rankdir=LR;{layout}
size="{size}";
ratio={ratio};
node [shape=plaintext]

{tnodes}

{edges}
}}
"""
    return Source(res) if render else res
