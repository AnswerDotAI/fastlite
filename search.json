[
  {
    "objectID": "core.html",
    "href": "core.html",
    "title": "Source",
    "section": "",
    "text": "from IPython.display import Markdown\nfrom fastcore.test import test_fail, test_eq\nfrom fastcore.net import urlsave\nimport logging\n\n\nurl = 'https://github.com/lerocha/chinook-database/raw/master/ChinookDatabase/DataSources/Chinook_Sqlite.sqlite'\npath = Path('chinook.sqlite')\nif not path.exists(): urlsave(url, path)\n\n\nlogging.getLogger('apsw').setLevel(logging.ERROR)\ndb = Database(\"chinook.sqlite\")\n\n\nsource\n\n\n\ndef t(\n    \n):\n\n\n\nExported source\nclass _Getter:\n    \"Abstract class with dynamic attributes providing access to DB objects\"\n    def __init__(self, db): self.db = db\n    # NB: Define `__dir__` in subclass to get list of objects\n    def __repr__(self): return \", \".join(dir(self))\n    def __contains__(self, s): return (s if isinstance(s,str) else s.name) in dir(self)\n    def __iter__(self): return iter(self[dir(self)])\n    def __getitem__(self, idxs):\n        if isinstance(idxs,str): return self.db.table(idxs)\n        return [self.db.table(o) for o in idxs]\n    def __getattr__(self, k):\n        if k[0]=='_': raise AttributeError\n        return self.db[k]\n\nclass _TablesGetter(_Getter):\n    def __dir__(self): return [o for o in self.db.table_names() if not o.startswith('sqlite_')]\n\n@patch(as_prop=True)\ndef t(self:Database): return _TablesGetter(self)\n\n\nBy returning a _TablesGetter we get a repr and auto-complete that shows all tables in the DB.\n\ndt = db.t\ndt\n\nAlbum, Artist, Customer, Employee, Genre, Invoice, InvoiceLine, MediaType, Playlist, PlaylistTrack, Track, pet_food\n\n\n\nartist = dt.Artist\nartist\n\n&lt;Table Artist (ArtistId, Name)&gt;\n\n\nThis also can be used to get multiple tables at once.\n\ndt['Album','Artist']\n\n[&lt;Table Album (AlbumId, Title, ArtistId)&gt;, &lt;Table Artist (ArtistId, Name)&gt;]\n\n\nYou can iterate through it:\n\nfor tbl in dt:\n    if tbl.name[0]=='A': print(tbl)\n\n\"Album\"\n\"Artist\"\n\n\n\nassert 'Artist' in dt\nassert artist in dt\nassert 'foo' not in dt\n\n\nsource\n\n\n\n\ndef c(\n    \n):\n\n\n\nExported source\nclass _Col:\n    def __init__(self, t, c): self.t,self.c = t,c\n    def __str__(self):  return f'\"{self.t}\".\"{self.c}\"'\n    def __repr__(self):  return self.c\n    def __iter__(self): return iter(self.c)\n\nclass _ColsGetter:\n    def __init__(self, tbl): self.tbl = tbl\n    def __dir__(self): return map(repr, self())\n    def __call__(self): return [_Col(self.tbl.name,o.name) for o in self.tbl.columns]\n    def __contains__(self, s): return (s if isinstance(s,str) else s.c) in self.tbl.columns_dict\n    def __repr__(self): return \", \".join(dir(self))\n\n    def __getattr__(self, k):\n        if k[0]=='_': raise AttributeError\n        return _Col(self.tbl.name, k)\n\n@patch(as_prop=True)\ndef c(self:Table): return _ColsGetter(self)\n\n@patch(as_prop=True)\ndef c(self:View): return _ColsGetter(self)\n\n\n\nsource\n\n\n\n\ndef c(\n    \n):\n\nColumn auto-complete and repr are much the same as tables.\n\nac = artist.c\nac\n\nArtistId, Name\n\n\nColumns stringify in a format suitable for including in SQL statements.\n\nprint(f\"select {ac.Name} ...\")\n\nselect \"Artist\".\"Name\" ...\n\n\n\nsource\n\n\n\n\ndef __str__(\n    \n):\n\nReturn str(self).\n\n\nExported source\n@patch\ndef __str__(self:Table): return f'\"{self.name}\"'\n\n@patch\ndef __str__(self:View): return f'\"{self.name}\"'\n\n\n\nsource\n\n\n\n\ndef __str__(\n    \n):\n\nReturn str(self).\nTables and views do the same.\n\nprint(f\"select {ac.Name} from {artist}\")\n\nselect \"Artist\".\"Name\" from \"Artist\"\n\n\n\nassert 'Name' in ac\nassert ac.Name in ac\nassert 'foo' not in ac",
    "crumbs": [
      "Source"
    ]
  },
  {
    "objectID": "core.html#metadata",
    "href": "core.html#metadata",
    "title": "Source",
    "section": "",
    "text": "from IPython.display import Markdown\nfrom fastcore.test import test_fail, test_eq\nfrom fastcore.net import urlsave\nimport logging\n\n\nurl = 'https://github.com/lerocha/chinook-database/raw/master/ChinookDatabase/DataSources/Chinook_Sqlite.sqlite'\npath = Path('chinook.sqlite')\nif not path.exists(): urlsave(url, path)\n\n\nlogging.getLogger('apsw').setLevel(logging.ERROR)\ndb = Database(\"chinook.sqlite\")\n\n\nsource\n\n\n\ndef t(\n    \n):\n\n\n\nExported source\nclass _Getter:\n    \"Abstract class with dynamic attributes providing access to DB objects\"\n    def __init__(self, db): self.db = db\n    # NB: Define `__dir__` in subclass to get list of objects\n    def __repr__(self): return \", \".join(dir(self))\n    def __contains__(self, s): return (s if isinstance(s,str) else s.name) in dir(self)\n    def __iter__(self): return iter(self[dir(self)])\n    def __getitem__(self, idxs):\n        if isinstance(idxs,str): return self.db.table(idxs)\n        return [self.db.table(o) for o in idxs]\n    def __getattr__(self, k):\n        if k[0]=='_': raise AttributeError\n        return self.db[k]\n\nclass _TablesGetter(_Getter):\n    def __dir__(self): return [o for o in self.db.table_names() if not o.startswith('sqlite_')]\n\n@patch(as_prop=True)\ndef t(self:Database): return _TablesGetter(self)\n\n\nBy returning a _TablesGetter we get a repr and auto-complete that shows all tables in the DB.\n\ndt = db.t\ndt\n\nAlbum, Artist, Customer, Employee, Genre, Invoice, InvoiceLine, MediaType, Playlist, PlaylistTrack, Track, pet_food\n\n\n\nartist = dt.Artist\nartist\n\n&lt;Table Artist (ArtistId, Name)&gt;\n\n\nThis also can be used to get multiple tables at once.\n\ndt['Album','Artist']\n\n[&lt;Table Album (AlbumId, Title, ArtistId)&gt;, &lt;Table Artist (ArtistId, Name)&gt;]\n\n\nYou can iterate through it:\n\nfor tbl in dt:\n    if tbl.name[0]=='A': print(tbl)\n\n\"Album\"\n\"Artist\"\n\n\n\nassert 'Artist' in dt\nassert artist in dt\nassert 'foo' not in dt\n\n\nsource\n\n\n\n\ndef c(\n    \n):\n\n\n\nExported source\nclass _Col:\n    def __init__(self, t, c): self.t,self.c = t,c\n    def __str__(self):  return f'\"{self.t}\".\"{self.c}\"'\n    def __repr__(self):  return self.c\n    def __iter__(self): return iter(self.c)\n\nclass _ColsGetter:\n    def __init__(self, tbl): self.tbl = tbl\n    def __dir__(self): return map(repr, self())\n    def __call__(self): return [_Col(self.tbl.name,o.name) for o in self.tbl.columns]\n    def __contains__(self, s): return (s if isinstance(s,str) else s.c) in self.tbl.columns_dict\n    def __repr__(self): return \", \".join(dir(self))\n\n    def __getattr__(self, k):\n        if k[0]=='_': raise AttributeError\n        return _Col(self.tbl.name, k)\n\n@patch(as_prop=True)\ndef c(self:Table): return _ColsGetter(self)\n\n@patch(as_prop=True)\ndef c(self:View): return _ColsGetter(self)\n\n\n\nsource\n\n\n\n\ndef c(\n    \n):\n\nColumn auto-complete and repr are much the same as tables.\n\nac = artist.c\nac\n\nArtistId, Name\n\n\nColumns stringify in a format suitable for including in SQL statements.\n\nprint(f\"select {ac.Name} ...\")\n\nselect \"Artist\".\"Name\" ...\n\n\n\nsource\n\n\n\n\ndef __str__(\n    \n):\n\nReturn str(self).\n\n\nExported source\n@patch\ndef __str__(self:Table): return f'\"{self.name}\"'\n\n@patch\ndef __str__(self:View): return f'\"{self.name}\"'\n\n\n\nsource\n\n\n\n\ndef __str__(\n    \n):\n\nReturn str(self).\nTables and views do the same.\n\nprint(f\"select {ac.Name} from {artist}\")\n\nselect \"Artist\".\"Name\" from \"Artist\"\n\n\n\nassert 'Name' in ac\nassert ac.Name in ac\nassert 'foo' not in ac",
    "crumbs": [
      "Source"
    ]
  },
  {
    "objectID": "core.html#queries-and-views",
    "href": "core.html#queries-and-views",
    "title": "Source",
    "section": "Queries and views",
    "text": "Queries and views\n\nsource\n\nDatabase.q\n\ndef q(\n    sql:str, params:NoneType=None\n):\n\n\n\nExported source\n@patch\ndef q(self:Database, sql: str, params=None):\n    return list(self.query(sql, params=params))\n\n\nThis is a minor shortcut for interactive use.\n\nacdc = db.q(f\"select * from {artist} where {ac.Name} like 'AC/%'\")\nacdc\n\n[{'ArtistId': 1, 'Name': 'AC/DC'}]\n\n\n\n\nExported source\ndef _get_flds(tbl): \n    return [(k, v|None, field(default=UNSET))\n            for k,v in tbl.columns_dict.items()]\n\ndef _dataclass(self:Table, store=True, suf='')-&gt;type:\n    \"Create a `dataclass` with the types and defaults of this table\"\n    res = make_dataclass(self.name.title()+suf, _get_flds(self))\n    flexiclass(res)\n    if store: self.cls = res\n    return res\n\nTable.dataclass = _dataclass\n\n\n\nartist_dc = artist.dataclass()\nart1_obj = artist_dc(**acdc[0])\nart1_obj\n\nArtist(ArtistId=1, Name='AC/DC')\n\n\n\nartist.cls\n\n__main__.Artist\n\n\nYou can get the definition of the dataclass using fastcore‚Äôs dataclass_src:\n\nsrc = dataclass_src(artist_dc)\nhl_md(src, 'python')\n\n@dataclass\nclass Artist:\n    ArtistId: int | None = UNSET\n    Name: str | None = UNSET\n\n\n\nsource\n\n\nall_dcs\n\ndef all_dcs(\n    db, with_views:bool=False, store:bool=True, suf:str=''\n):\n\ndataclasses for all objects in db\n\n\nExported source\ndef all_dcs(db, with_views=False, store=True, suf=''):\n    \"dataclasses for all objects in `db`\"\n    return [o.dataclass(store=store, suf=suf) for o in list(db.t) + (db.views if with_views else [])]\n\n\n\nsource\n\n\ncreate_mod\n\ndef create_mod(\n    db, mod_fn, with_views:bool=False, store:bool=True, suf:str=''\n):\n\nCreate module for dataclasses for db\n\n\nExported source\ndef create_mod(db, mod_fn, with_views=False, store=True, suf=''):\n    \"Create module for dataclasses for `db`\"\n    mod_fn = str(mod_fn)\n    if not mod_fn.endswith('.py'): mod_fn+='.py'\n    dcs = all_dcs(db, with_views, store=store, suf=suf)\n    strlist = ', '.join([f'\"{o.__name__}\"' for o in dcs])\n    with open(mod_fn, 'w') as f:\n        print(f'__all__ = [{strlist}]', file=f)\n        print('from dataclasses import dataclass', file=f)\n        print('from fastlite.kw import UNSET', file=f)\n        for o in dcs: print(dataclass_src(o), file=f)\n\n\n\ncreate_mod(db, 'db_dc')\n\n\nsource\n\n\nDatabase.link_dcs\n\ndef link_dcs(\n    mod\n):\n\nSet the internal dataclass type links for tables using mod (created via create_mod)\n\nfrom db_dc import *\ndt.Track.get(1)\n\nTrack(TrackId=1, Name='For Those About To Rock (We Salute You)', AlbumId=1, MediaTypeId=1, GenreId=1, Composer='Angus Young, Malcolm Young, Brian Johnson', Milliseconds=343719, Bytes=11170334, UnitPrice=0.99)\n\n\n\nsource\n\n\nTable.__call__\n\ndef __call__(\n    where:str | None=None, # SQL where fragment to use, for example `id &gt; ?`\n    where_args:Union=None, # Parameters to use with `where`; iterable for `id&gt;?`, or dict for `id&gt;:id`\n    order_by:str | None=None, # Column or fragment of SQL to order by\n    limit:int | None=None, # Number of rows to limit to\n    offset:int | None=None, # SQL offset\n    select:str='*', # Comma-separated list of columns to select\n    with_pk:bool=False, # Return tuple of (pk,row)?\n    as_cls:bool=True, # Convert returned dict to stored dataclass?\n    xtra:dict | None=None, # Extra constraints\n    kwargs:VAR_KEYWORD\n)-&gt;list:\n\nShortcut for rows_where or pks_and_rows_where, depending on with_pk\n\n\nExported source\n@patch\ndef __call__(\n    self:Table,\n    where:str|None=None,  # SQL where fragment to use, for example `id &gt; ?`\n    where_args: Iterable|dict|NoneType=None, # Parameters to use with `where`; iterable for `id&gt;?`, or dict for `id&gt;:id`\n    order_by: str|None=None, # Column or fragment of SQL to order by\n    limit:int|None=None, # Number of rows to limit to\n    offset:int|None=None, # SQL offset\n    select:str = \"*\", # Comma-separated list of columns to select\n    with_pk:bool=False, # Return tuple of (pk,row)?\n    as_cls:bool=True, # Convert returned dict to stored dataclass?\n    xtra:dict|None=None, # Extra constraints\n    **kwargs)-&gt;list:\n    \"Shortcut for `rows_where` or `pks_and_rows_where`, depending on `with_pk`\"\n    f = getattr(self, 'pks_and_rows_where' if with_pk else 'rows_where')\n    if not xtra: xtra = getattr(self, 'xtra_id', {})\n    if xtra:\n        xw = ' and '.join(f\"[{k}] = {v!r}\" for k,v in xtra.items())\n        where = f'{xw} and {where}' if where else xw\n    res = f(where=where, where_args=where_args, order_by=order_by, limit=limit, offset=offset, select=select, **kwargs)\n    if as_cls and hasattr(self,'cls'):\n        if with_pk: res = ((k,self.cls(**v)) for k,v in res)\n        else: res = (self.cls(**o) for o in res)\n    return list(res)\nView.__call__ = Table.__call__\n\n\nThis calls either rows_where (if with_pk) or with_pk (otherwise). If dataclass(store=True) has been called, then if as_cls rows will be returned as dataclass objects.\n\nartist(limit=2)\n\n[Artist(ArtistId=1, Name='AC/DC'), Artist(ArtistId=2, Name='Accept')]\n\n\nIf with_pk then tuples are returns with PKs 1st.\n\nartist(with_pk=True, limit=2)\n\n[(1, Artist(ArtistId=1, Name='AC/DC')), (2, Artist(ArtistId=2, Name='Accept'))]\n\n\n\nartist.get(1)\n\nArtist(ArtistId=1, Name='AC/DC')\n\n\n\nsource\n\n\nTable.selectone\n\ndef selectone(\n    where:str | None=None, # SQL where fragment to use, for example `id &gt; ?`\n    where_args:Union=None, # Parameters to use with `where`; iterable for `id&gt;?`, or dict for `id&gt;:id`\n    select:str='*', # Comma-separated list of columns to select\n    as_cls:bool=True, # Convert returned dict to stored dataclass?\n    xtra:dict | None=None, # Extra constraints\n    kwargs:VAR_KEYWORD\n)-&gt;list:\n\nShortcut for __call__ that returns exactly one item\n\n\nExported source\n@patch\ndef selectone(\n    self:Table,\n    where:str|None=None,  # SQL where fragment to use, for example `id &gt; ?`\n    where_args: Iterable|dict|NoneType=None, # Parameters to use with `where`; iterable for `id&gt;?`, or dict for `id&gt;:id`\n    select:str = \"*\", # Comma-separated list of columns to select\n    as_cls:bool=True, # Convert returned dict to stored dataclass?\n    xtra:dict|None=None, # Extra constraints\n    **kwargs)-&gt;list:\n    \"Shortcut for `__call__` that returns exactly one item\"\n    res = self(where=where, where_args=where_args, select=select, as_cls=as_cls, xtra=xtra, limit=2)\n    if len(res)==0: raise NotFoundError\n    elif len(res) &gt; 1: raise ValueError(f\"Not unique: {len(res)} results\")\n    return res[0]\nView.selectone = Table.selectone\n\n\n\nartist.selectone('Name=?', ('AC/DC',))\n\nArtist(ArtistId=1, Name='AC/DC')\n\n\n\ntry: artist.selectone('Name like ?', ('%a%',))\nexcept ValueError: pass\nelse: raise Exception(\"Failed to get non unique exception\")\n\n\ntry: artist.selectone('Name=?', ('i do not exist',))\nexcept NotFoundError: pass\nelse: raise Exception(\"Failed to get NotFoundError\")\n\n\ndb.item('select ArtistId from artist where Name=?', ('AC/DC',))\n\n1\n\n\n\nsource\n\n\nDatabase.set_classes\n\ndef set_classes(\n    glb\n):\n\nAdd set all table dataclasses using types in namespace glb\n\n\nExported source\n@patch\ndef set_classes(self:Database, glb):\n    \"Add set all table dataclasses using types in namespace `glb`\"\n    for tbl in self.t: tbl.cls = glb[tbl.name.title()]\n\n\n\ndb.t\n\nAlbum, Artist, Customer, Employee, Genre, Invoice, InvoiceLine, MediaType, Playlist, PlaylistTrack, Track, cat, pet_food\n\n\n\nsource\n\n\nDatabase.get_tables\n\ndef get_tables(\n    glb\n):\n\nAdd objects for all table objects to namespace glb\n\n\nExported source\n@patch\ndef get_tables(self:Database, glb):\n    \"Add objects for all table objects to namespace `glb`\"\n    for tbl in self.t: glb[tbl.name.lower()+'s'] = tbl\n\n\n\ndb.set_classes(globals())\ndb.get_tables(globals())\n\nalbums(limit=1)\n\n[Album(AlbumId=1, Title='For Those About To Rock We Salute You', ArtistId=1)]\n\n\n\nalbum = dt.Album\nacca_sql = f\"\"\"select {album}.*\nfrom {album} join {artist} using (ArtistId)\nwhere {ac.Name} like 'AC/%'\"\"\"\n\nhl_md(acca_sql, 'sql')\n\nselect \"Album\".*\nfrom \"Album\" join \"Artist\" using (ArtistId)\nwhere \"Artist\".\"Name\" like 'AC/%'\n\n\n\ndb.q(acca_sql)\n\n[{'AlbumId': 1,\n  'Title': 'For Those About To Rock We Salute You',\n  'ArtistId': 1},\n {'AlbumId': 4, 'Title': 'Let There Be Rock', 'ArtistId': 1}]\n\n\n\ndb.create_view(\"AccaDaccaAlbums\", acca_sql, replace=True)\n\n&lt;Database &lt;apsw.Connection object \"/Users/jhoward/aai-ws/fastlite/nbs/chinook.sqlite\"&gt;&gt;\n\n\n\nsource\n\n\nDatabase.v\n\ndef v(\n    \n):\n\n\n\nExported source\nclass _ViewsGetter(_Getter):\n    def __dir__(self): return self.db.view_names()\n\n@patch(as_prop=True)\ndef v(self:Database): return _ViewsGetter(self)\n\n\n\ndv = db.v\ndv\n\nAccaDaccaAlbums\n\n\n\ndv.AccaDaccaAlbums()\n\n[{'AlbumId': 1,\n  'Title': 'For Those About To Rock We Salute You',\n  'ArtistId': 1},\n {'AlbumId': 4, 'Title': 'Let There Be Rock', 'ArtistId': 1}]\n\n\n\n\nExported source\ndef _parse_typ(t): return t if not (_args:= get_args(t)) else first(_args, bool)\n\n\n\n_parse_typ(Union[int, None])\n\nint\n\n\n\nsource\n\n\nget_typ\n\ndef get_typ(\n    t\n):\n\nGet the underlying type.\n\nget_typ(Union[int, None])\n\nint\n\n\n\nget_typ(int)\n\nint\n\n\nIf you have an Enum where all the fields are the same type, then _get_typ will return that type.\n\nclass _Test(Enum): foo='val1'; bar=2\nclass _Test2(Enum): foo='val3'; bar='val4'\n\n\n# fields are not the same type\nget_typ(_Test)\n\n&lt;enum '_Test'&gt;\n\n\n\n# fields are all of type `str`\nget_typ(_Test2)\n\nstr\n\n\n\nsource\n\n\nDatabase.create\n\ndef create(\n    cls:NoneType=None, # Dataclass to create table from\n    name:NoneType=None, # Name of table to create\n    pk:str='id', # Column(s) to use as a primary key\n    foreign_keys:NoneType=None, # Foreign key definitions\n    defaults:NoneType=None, # Database table defaults\n    column_order:NoneType=None, # Which columns should come first\n    not_null:NoneType=None, # Columns that should be created as ``NOT NULL``\n    hash_id:NoneType=None, # Column to be used as a primary key using hash\n    hash_id_columns:NoneType=None, # Columns used when calculating hash\n    extracts:NoneType=None, # Columns to be extracted during inserts\n    if_not_exists:bool=False, # Use `CREATE TABLE IF NOT EXISTS`\n    replace:bool=False, # Drop and replace table if it already exists\n    ignore:bool=True, # Silently do nothing if table already exists\n    transform:bool=False, # If table exists transform it to fit schema\n    strict:bool=False, # Apply STRICT mode to table\n):\n\nCreate table from cls, default name to snake-case version of class name\nThe class you pass to create is converted to a dataclass where any fields missing a default are defaulted to None.\n\nclass Nm(Enum): fn='meow'; ln='prr' \n            \nclass Cat: id: int; name:Nm|None; age: int|None; city: str = \"Unknown\"\ncats = db.create(Cat)\nCat(1)\n\nCat(id=1, name=UNSET, age=UNSET, city='Unknown')\n\n\n\nprint(cats.schema)\n\nCREATE TABLE [cat] (\n   [id] INTEGER PRIMARY KEY,\n   [name] TEXT,\n   [weight] FLOAT\n)\n\n\n\ndb.create(Cat)\n\n&lt;Table cat (id, name, weight)&gt;\n\n\nTo transform a table after creation, use the .create() method again, this time with the transform keyword set to True.\n\nclass Cat: id: int; name: str; age: int; city: str = \"Unknown\"; breed: str = \"Unknown\"\ncats = db.create(Cat, transform=True)\ncats\n\n&lt;Table cat (id, name, age, city, breed)&gt;\n\n\n\nCat(1)\n\nCat(id=1, name=UNSET, age=UNSET, city='Unknown', breed='Unknown')\n\n\n\nprint(cats.schema)\n\nCREATE TABLE \"cat\" (\n   [id] INTEGER PRIMARY KEY,\n   [name] TEXT,\n   [age] INTEGER,\n   [city] TEXT,\n   [breed] TEXT\n)\n\n\n\ndb.t.cat.drop()\n\n\nsource\n\n\nDatabase.import_file\n\ndef import_file(\n    table_name, file, format:NoneType=None, pk:NoneType=None, alter:bool=False\n):\n\nImport path or handle file to new table table_name\nThis uses sqlite_utils.utils.rows_from_file to load the file.\n\ndb = Database(\":memory:\")\ncsv1 = \"id,name,age\\n1,Alice,30\\n2,Bob,25\"\ncsv2 = \"id,name,age\\n3,Charlie,35\\n4,David,40\"\ncsv3 = \"id,name,age,city\\n5,Eve,45,New York\"\n\n# import file to new table\ntbl = db.import_file(\"people\", csv1)\nassert len(tbl()) == 2\n\n# import file to existing table (same schema)\ntbl = db.import_file(\"people\", csv2)\nassert len(tbl()) == 4\n\n# import file to existing table (schema change fails)\ntest_fail(lambda: db.import_file(\"people\", csv3),contains='city')\n\n# import file to existing table (schema change succeeds)\nassert 'city' not in tbl.c\ntbl = db.import_file(\"people\", csv3, alter=True)\nassert 'city' in tbl.c\n\nprint(tbl())\ntbl.drop()\n\n[{'id': 1, 'name': 'Alice', 'age': 30, 'city': None}, {'id': 2, 'name': 'Bob', 'age': 25, 'city': None}, {'id': 3, 'name': 'Charlie', 'age': 35, 'city': None}, {'id': 4, 'name': 'David', 'age': 40, 'city': None}, {'id': 5, 'name': 'Eve', 'age': 45, 'city': 'New York'}]",
    "crumbs": [
      "Source"
    ]
  },
  {
    "objectID": "core.html#database-diagrams",
    "href": "core.html#database-diagrams",
    "title": "Source",
    "section": "Database diagrams",
    "text": "Database diagrams\n(Requires graphviz.)\n\nfk = album.foreign_keys[0]\nfk\n\nForeignKey(table='Album', column='ArtistId', other_table='Artist', other_column='ArtistId')\n\n\n\nsource\n\ndiagram\n\ndef diagram(\n    tbls, ratio:float=0.7, size:str='10', neato:bool=False, render:bool=True\n):\n\n\n\nExported source\ndef _edge(tbl):\n    return \"\\n\".join(f\"{fk.table}:{fk.column} -&gt; {fk.other_table}:{fk.other_column};\"\n                     for fk in tbl.foreign_keys)\n\ndef _row(col):\n    xtra = \" üîë\" if col.is_pk else \"\"\n    bg = ' bgcolor=\"#ffebcd\"' if col.is_pk else \"\"\n    return f'    &lt;tr&gt;&lt;td port=\"{col.name}\"{bg}&gt;{col.name}{xtra}&lt;/td&gt;&lt;/tr&gt;'\n\ndef _tnode(tbl):\n    rows = \"\\n\".join(_row(o) for o in tbl.columns)\n    res = f\"\"\"&lt;table cellborder=\"1\" cellspacing=\"0\"&gt;\n    &lt;tr&gt;&lt;td bgcolor=\"lightgray\"&gt;{tbl.name}&lt;/td&gt;&lt;/tr&gt;\n{rows}\n  &lt;/table&gt;\"\"\"\n    return f\"{tbl.name} [label=&lt;{res}&gt;];\\n\"\n\n\n\n\nExported source\ndef diagram(tbls, ratio=0.7, size=\"10\", neato=False, render=True):\n    layout = \"\\nlayout=neato;\\noverlap=prism;\\noverlap_scaling=0.5;\"\"\" if neato else \"\"\n    edges  = \"\\n\".join(map(_edge,  tbls))\n    tnodes = \"\\n\".join(map(_tnode, tbls))\n    \n    res = f\"\"\"digraph G {{\nrankdir=LR;{layout}\nsize=\"{size}\";\nratio={ratio};\nnode [shape=plaintext]\n\n{tnodes}\n\n{edges}\n}}\n\"\"\"\n    return Source(res) if render else res\n\n\n\ndb = Database(\"chinook.sqlite\")\n\n\ndiagram(db.tables)",
    "crumbs": [
      "Source"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "fastlite",
    "section": "",
    "text": "fastlite provides some little quality-of-life improvements for interactive use of the wonderful sqlite-utils library. It‚Äôs likely to be particularly of interest to folks using Jupyter.",
    "crumbs": [
      "fastlite"
    ]
  },
  {
    "objectID": "index.html#install",
    "href": "index.html#install",
    "title": "fastlite",
    "section": "Install",
    "text": "Install\npip install fastlite",
    "crumbs": [
      "fastlite"
    ]
  },
  {
    "objectID": "index.html#overview",
    "href": "index.html#overview",
    "title": "fastlite",
    "section": "Overview",
    "text": "Overview\n\nfrom fastlite import *\nfrom fastcore.utils import *\nfrom fastcore.net import urlsave\n\nWe demonstrate fastlite‚Äòs features here using the ‚Äôchinook‚Äô sample database.\n\nurl = 'https://github.com/lerocha/chinook-database/raw/master/ChinookDatabase/DataSources/Chinook_Sqlite.sqlite'\npath = Path('chinook.sqlite')\nif not path.exists(): urlsave(url, path)\n\ndb = database(\"chinook.sqlite\")\n\nDatabases have a t property that lists all tables:\n\ndt = db.t\ndt\n\nAlbum, Artist, Customer, Employee, Genre, Invoice, InvoiceLine, MediaType, Playlist, PlaylistTrack, Track\n\n\nYou can use this to grab a single table‚Ä¶:\n\nartist = dt.artists\nartist\n\n&lt;Table artists (does not exist yet)&gt;\n\n\n\nartist = dt.Artist\nartist\n\n&lt;Table Artist (ArtistId, Name)&gt;\n\n\n‚Ä¶or multiple tables at once:\n\ndt['Artist','Album','Track','Genre','MediaType']\n\n[&lt;Table Artist (ArtistId, Name)&gt;,\n &lt;Table Album (AlbumId, Title, ArtistId)&gt;,\n &lt;Table Track (TrackId, Name, AlbumId, MediaTypeId, GenreId, Composer, Milliseconds, Bytes, UnitPrice)&gt;,\n &lt;Table Genre (GenreId, Name)&gt;,\n &lt;Table MediaType (MediaTypeId, Name)&gt;]\n\n\nIt also provides auto-complete in Jupyter, IPython, and nearly any other interactive Python environment:\n\nYou can check if a table is in the database already:\n\n'Artist' in dt\n\nTrue\n\n\nColumn work in a similar way to tables, using the c property:\n\nac = artist.c\nac\n\nArtistId, Name\n\n\nAuto-complete works for columns too:\n\nColumns, tables, and view stringify in a format suitable for including in SQL statements. That means you can use auto-complete in f-strings.\n\nqry = f\"select * from {artist} where {ac.Name} like 'AC/%'\"\nprint(qry)\n\nselect * from \"Artist\" where \"Artist\".\"Name\" like 'AC/%'\n\n\nYou can view the results of a select query using q:\n\ndb.q(qry)\n\n[{'ArtistId': 1, 'Name': 'AC/DC'}]\n\n\nViews can be accessed through the v property:\n\nalbum = dt.Album\n\nacca_sql = f\"\"\"select {album}.*\nfrom {album} join {artist} using (ArtistId)\nwhere {ac.Name} like 'AC/%'\"\"\"\n\ndb.create_view(\"AccaDaccaAlbums\", acca_sql, replace=True)\nacca_dacca = db.q(f\"select * from {db.v.AccaDaccaAlbums}\")\nacca_dacca\n\n[{'AlbumId': 1,\n  'Title': 'For Those About To Rock We Salute You',\n  'ArtistId': 1},\n {'AlbumId': 4, 'Title': 'Let There Be Rock', 'ArtistId': 1}]",
    "crumbs": [
      "fastlite"
    ]
  },
  {
    "objectID": "index.html#dataclass-support",
    "href": "index.html#dataclass-support",
    "title": "fastlite",
    "section": "Dataclass support",
    "text": "Dataclass support\nA dataclass type with the names, types, and defaults of the tables is created using dataclass():\n\nalbum_dc = album.dataclass()\n\nLet‚Äôs try it:\n\nalbum_obj = album_dc(**acca_dacca[0])\nalbum_obj\n\nAlbum(AlbumId=1, Title='For Those About To Rock We Salute You', ArtistId=1)\n\n\nYou can get the definition of the dataclass using fastcore‚Äôs dataclass_src ‚Äì everything is treated as nullable, in order to handle auto-generated database values:\n\nsrc = dataclass_src(album_dc)\nhl_md(src, 'python')\n\n@dataclass\nclass Album:\n    AlbumId: int | None = None\n    Title: str | None = None\n    ArtistId: int | None = None\n\n\nBecause dataclass() is dynamic, you won‚Äôt get auto-complete in editors like vscode ‚Äì it‚Äôll only work in dynamic environments like Jupyter and IPython. For editor support, you can export the full set of dataclasses to a module, which you can then import from:\n\ncreate_mod(db, 'db_dc')\n\n\nfrom db_dc import Track\nTrack()\n\nTrack(TrackId=None, Name=None, AlbumId=None, MediaTypeId=None, GenreId=None, Composer=None, Milliseconds=None, Bytes=None, UnitPrice=None)\n\n\nIndexing into a table does a query on primary key:\n\ndt.Track[1]\n\nTrack(TrackId=1, Name='For Those About To Rock (We Salute You)', AlbumId=1, MediaTypeId=1, GenreId=1, Composer='Angus Young, Malcolm Young, Brian Johnson', Milliseconds=343719, Bytes=11170334, UnitPrice=0.99)\n\n\nThere‚Äôs a shortcut to select from a table ‚Äì just call it as a function. If you‚Äôve previously called dataclass(), returned iterms will be constructed using that class by default. There‚Äôs lots of params you can check out, such as limit:\n\nalbum(limit=2)\n\n[Album(AlbumId=1, Title='For Those About To Rock We Salute You', ArtistId=1),\n Album(AlbumId=2, Title='Balls to the Wall', ArtistId=2)]\n\n\nPass a truthy value as with_pk and you‚Äôll get tuples of primary keys and records:\n\nalbum(with_pk=1, limit=2)\n\n[(1,\n  Album(AlbumId=1, Title='For Those About To Rock We Salute You', ArtistId=1)),\n (2, Album(AlbumId=2, Title='Balls to the Wall', ArtistId=2))]\n\n\nIndexing also uses the dataclass by default:\n\nalbum[5]\n\nAlbum(AlbumId=5, Title='Big Ones', ArtistId=3)\n\n\nIf you set xtra fields, then indexing is also filtered by those. As a result, for instance in this case, nothing is returned since album 5 is not created by artist 1:\n\nalbum.xtra(ArtistId=1)\n\ntry: album[5]\nexcept NotFoundError: print(\"Not found\")\n\nNot found\n\n\nThe same filtering is done when using the table as a callable:\n\nalbum()\n\n[Album(AlbumId=1, Title='For Those About To Rock We Salute You', ArtistId=1),\n Album(AlbumId=4, Title='Let There Be Rock', ArtistId=1)]",
    "crumbs": [
      "fastlite"
    ]
  },
  {
    "objectID": "index.html#core-design",
    "href": "index.html#core-design",
    "title": "fastlite",
    "section": "Core design",
    "text": "Core design\nThe following methods accept **kwargs, passing them along to the first dict param:\n\ncreate\ntransform\ntransform_sql\nupdate\ninsert\nupsert\nlookup\n\nWe can access a table that doesn‚Äôt actually exist yet:\n\ncats = dt.cats\ncats\n\n&lt;Table cats (does not exist yet)&gt;\n\n\nWe can use keyword arguments to now create that table:\n\ncats.create(id=int, name=str, weight=float, uid=int, pk='id')\nhl_md(cats.schema, 'sql')\n\nCREATE TABLE [cats] (\n   [id] INTEGER PRIMARY KEY,\n   [name] TEXT,\n   [weight] FLOAT,\n   [uid] INTEGER\n)\n\n\nIt we set xtra then the additional fields are used for insert, update, and delete:\n\ncats.xtra(uid=2)\ncat = cats.insert(name='meow', weight=6)\n\nThe inserted row is returned, including the xtra ‚Äòuid‚Äô field.\n\ncat\n\n{'id': 1, 'name': 'meow', 'weight': 6.0, 'uid': 2}\n\n\nUsing ** in update here doesn‚Äôt actually achieve anything, since we can just pass a dict directly ‚Äì it‚Äôs just to show that it works:\n\ncat['name'] = \"moo\"\ncat['uid'] = 1\ncats.update(**cat)\ncats()\n\n[{'id': 1, 'name': 'moo', 'weight': 6.0, 'uid': 2}]\n\n\nAttempts to update or insert with xtra fields are ignored.\nAn error is raised if there‚Äôs an attempt to update a record not matching xtra fields:\n\ncats.xtra(uid=1)\ntry: cats.update(**cat)\nexcept NotFoundError: print(\"Not found\")\n\nNot found\n\n\nThis all also works with dataclasses:\n\ncats.xtra(uid=2)\ncats.dataclass()\ncat = cats[1]\ncat\n\nCats(id=1, name='moo', weight=6.0, uid=2)\n\n\n\ncats.drop()\ncats\n\n&lt;Table cats (does not exist yet)&gt;\n\n\nAlternatively, you can create a table from a class. If it‚Äôs not already a dataclass, it will be converted into one. In either case, the dataclass will be created (or modified) so that None can be passed to any field (this is needed to support fields such as automatic row ids).\n\nclass Cat: id:int; name:str; weight:float; uid:int\n\n\ncats = db.create(Cat)\n\n\nhl_md(cats.schema, 'sql')\n\nCREATE TABLE [cat] (\n   [id] INTEGER PRIMARY KEY,\n   [name] TEXT,\n   [weight] FLOAT,\n   [uid] INTEGER\n)\n\n\n\ncat = Cat(name='Âí™Âí™', weight=9)\ncats.insert(cat)\n\nCat(id=1, name='Âí™Âí™', weight=9.0, uid=None)\n\n\n\ncats.drop()",
    "crumbs": [
      "fastlite"
    ]
  },
  {
    "objectID": "index.html#manipulating-data",
    "href": "index.html#manipulating-data",
    "title": "fastlite",
    "section": "Manipulating data",
    "text": "Manipulating data\nWe try to make the following methods as flexible as possible. Wherever possible, they support Python dictionaries, dataclasses, and classes.\n\n.insert()\nCreates a record. Returns an instance of the updated record.\nInsert using a dictionary.\n\ncats.insert({'name': 'Rex', 'weight': 12.2})\n\nCat(id=1, name='Rex', weight=12.2, uid=UNSET)\n\n\nInsert using a dataclass.\n\nCatDC = cats.dataclass()\ncats.insert(CatDC(name='Tom', weight=10.2))\n\nCat(id=2, name='Tom', weight=10.2)\n\n\nInsert using a standard Python class\n\ncat = cats.insert(Cat(name='Jerry', weight=5.2))\n\n\n\n.update()\nUpdates a record using a Python dict, dataclass, or object, and returns an instance of the updated record.\nUpdating from a Python dict:\n\ncats.update(dict(id=cat.id, name='Jerry', weight=6.2))\n\nCat(id=3, name='Jerry', weight=6.2)\n\n\nUpdating from a dataclass:\n\ncats.update(CatDC(id=cat.id, name='Jerry', weight=6.3))\n\nCat(id=3, name='Jerry', weight=6.3)\n\n\nUpdating using a class:\n\ncats.update(Cat(id=cat.id, name='Jerry', weight=5.7))\n\nCat(id=3, name='Jerry', weight=5.7)\n\n\n\n\n.delete()\nRemoving data is done by providing the primary key value of the record.\n\n# Farewell Jerry!\ncats.delete(cat.id)\n\n&lt;Table cat (id, name, weight)&gt;\n\n\n\n\nMulti-field primary keys\nPass a collection of strings to create a multi-field pk:\n\nclass PetFood: catid:int; food:str; qty:int\npetfoods = db.create(PetFood, pk=['catid','food'])\nprint(petfoods.schema)\n\nCREATE TABLE [pet_food] (\n   [catid] INTEGER,\n   [food] TEXT,\n   [qty] INTEGER,\n   PRIMARY KEY ([catid], [food])\n)\n\n\nYou can index into these using multiple values:\n\npf = petfoods.insert(PetFood(1, 'tuna', 2))\npetfoods[1,'tuna']\n\nPetFood(catid=1, food='tuna', qty=2)\n\n\nUpdates work in the usual way:\n\npf.qty=3\npetfoods.update(pf)\n\nPetFood(catid=1, food='tuna', qty=3)\n\n\nYou can also use upsert to update if the key exists, or insert otherwise:\n\npf.qty=1\npetfoods.upsert(pf)\npetfoods()\n\n[PetFood(catid=1, food='tuna', qty=1)]\n\n\n\npf.food='salmon'\npetfoods.upsert(pf)\npetfoods()\n\n[PetFood(catid=1, food='tuna', qty=1), PetFood(catid=1, food='salmon', qty=1)]\n\n\ndelete takes a tuple of keys:\n\npetfoods.delete((1, 'tuna'))\npetfoods()\n\n[PetFood(catid=1, food='salmon', qty=1)]",
    "crumbs": [
      "fastlite"
    ]
  },
  {
    "objectID": "index.html#diagrams",
    "href": "index.html#diagrams",
    "title": "fastlite",
    "section": "Diagrams",
    "text": "Diagrams\nIf you have graphviz installed, you can create database diagrams. Pass a subset of tables to just diagram those. You can also adjust the size and aspect ratio.\n\ndiagram(db.t['Artist','Album','Track','Genre','MediaType'], size=8, ratio=0.4)\n\n\n\n\n\n\n\n\n\nImporting CSV/TSV/etc\n\nsource\n\n\nDatabase.import_file\n\ndef import_file(\n    table_name, file, format:NoneType=None, pk:NoneType=None, alter:bool=False\n):\n\nImport path or handle file to new table table_name\nYou can pass a file name, string, bytes, or open file handle to import_file to import a CSV:\n\ndb = Database(\":memory:\")\ncsv_data = \"\"\"id,name,age\n1,Alice,30\n2,Bob,25\n3,Charlie,35\"\"\"\n\ntable = db.import_file(\"people\", csv_data)\ntable()\n\n[{'id': 1, 'name': 'Alice', 'age': 30},\n {'id': 2, 'name': 'Bob', 'age': 25},\n {'id': 3, 'name': 'Charlie', 'age': 35}]",
    "crumbs": [
      "fastlite"
    ]
  },
  {
    "objectID": "test_upsert.html",
    "href": "test_upsert.html",
    "title": "Test Upsert Operations",
    "section": "",
    "text": "from fastlite import *\n\nNote: Make sure to use fastlite‚Äôs database() here\n\ndb = database(':memory:')\n\n\nclass People: id: int; name: str\n\n\npeople = db.create(People, pk='id')",
    "crumbs": [
      "Test Upsert Operations"
    ]
  },
  {
    "objectID": "test_upsert.html#setup",
    "href": "test_upsert.html#setup",
    "title": "Test Upsert Operations",
    "section": "",
    "text": "from fastlite import *\n\nNote: Make sure to use fastlite‚Äôs database() here\n\ndb = database(':memory:')\n\n\nclass People: id: int; name: str\n\n\npeople = db.create(People, pk='id')",
    "crumbs": [
      "Test Upsert Operations"
    ]
  },
  {
    "objectID": "test_upsert.html#test-single-upserts",
    "href": "test_upsert.html#test-single-upserts",
    "title": "Test Upsert Operations",
    "section": "Test Single Upserts",
    "text": "Test Single Upserts\nHere we test upsert()\n\nTest Cases for upsert() Where Nothing Is Inserted\nTest that calling upsert() without any parameters doesn‚Äôt change anything, and returns nothing\n\npeople.upsert()\n\n{}\n\n\nTest None doesn‚Äôt change anything.\n\ncount = people.count\nassert people.upsert(None) == {}\nassert people.count == count\n\nTest empty dict doesn‚Äôt change anything\n\ncount = people.count\nassert people.upsert({}) == {}\nassert people.count == count\n\n\n# Test empty dataclass doesn't change anything\nPersonDC = people.dataclass()\ncount = people.count\nassert people.upsert(PersonDC()) == {}\nassert people.count == count\n\n\n# Test empty class instance doesn't change anything\nclass EmptyPerson: pass\ncount = people.count\nassert people.upsert(EmptyPerson()) == {}\nassert people.count == count\n\n\n\nSingle Insert Types\nTest upsert with keyword argument without id. Result should be a MissingPrimaryKey error\n\ntry: people.upsert(name='Alice')\nexcept (MissingPrimaryKey,KeyError): print('Correct throwing of key error')\n\nCorrect throwing of key error\n\n\nUse upsert to insert a new record via a dataclass. Since it can‚Äôt find the id, it adds the record\n\nperson = people.upsert(People(name='Alice', id=people.count+1))\n\nTest upsert that updates with dataclass. Since it can find the id, it updates the record.\n\nassert people.upsert(People(name='Bobba', id=person.id)).name == 'Bobba'\n\nUse upsert to insert a new record via a class. Since it can‚Äôt find the id, it adds the record\n\ncount = people.count\nclass Student: pass\nstudent = Student()\nstudent.name = 'Daniel Greenfeld'\nstudent.id = people.count+1\n\nassert people.upsert(student).name == 'Daniel Greenfeld'\nassert people.count == count+1\n\nTest upsert that updates with class. Since it can find the id, it updates the record.\n\ncount = people.count\nstudent = Student()\nstudent.name = 'Daniel Roy Greenfeld'\nstudent.id = person.id\n\nassert people.upsert(student).name == 'Daniel Roy Greenfeld'\nassert people.count == count\n\n\n\nNone and Empty String Handling\nTest upserting a record with name set to None. First assert checks the method result, the second assert tests that the database was altered correctly.\n\nresult = people.upsert(People(name=None, id=person.id))\nassert result.name is None\nassert people[person.id].name is None\n\nTest with empty string.\n\nresult = people.upsert(People(name='', id=person.id))\nassert result.name == ''\nassert people[person.id].name == ''\n\n\n\nOther Cases\nTest upserts with special characters. Let‚Äôs do updates first\n\nassert people.upsert(People(name='O\\'Connor', id=person.id)).name == \"O'Connor\"\nassert people[person.id].name == \"O'Connor\"\nassert people.upsert(People(name='Jos√©', id=person.id)).name == 'Jos√©'\nassert people[person.id].name == \"Jos√©\"\n\nNow test special characters with upserts that insert.\n\nperson = people.upsert(People(name='O\\'Connor', id=people.count+1))\nassert person.name == \"O'Connor\"\nassert people[person.id].name == \"O'Connor\"\nperson = people.upsert(People(name='Jos√©', id=people.count+1))\nassert person.name == \"Jos√©\"\nassert people[person.id].name == \"Jos√©\"\n\nTest dict upsert\n\nassert people.upsert({'name': 'Dict Test', 'id': person.id}).name == 'Dict Test'\n\nTest that extra fields raise fastlite.SqlError\n\ntry:\n    p = people.upsert(dict(name='Extra', age=25, title='Dr', id=person.id))\nexcept SQLError as e:\n    assert e.args[0] == 'no such column: age'",
    "crumbs": [
      "Test Upsert Operations"
    ]
  },
  {
    "objectID": "test_insert.html",
    "href": "test_insert.html",
    "title": "Test Insert Operations",
    "section": "",
    "text": "from fastlite import *\n\nNote: Make sure to use fastlite‚Äôs database() here\n\ndb = database(':memory:')\n\n\nclass People: id: int; name: str\n\n\npeople = db.create(People, pk='id')",
    "crumbs": [
      "Test Insert Operations"
    ]
  },
  {
    "objectID": "test_insert.html#setup",
    "href": "test_insert.html#setup",
    "title": "Test Insert Operations",
    "section": "",
    "text": "from fastlite import *\n\nNote: Make sure to use fastlite‚Äôs database() here\n\ndb = database(':memory:')\n\n\nclass People: id: int; name: str\n\n\npeople = db.create(People, pk='id')",
    "crumbs": [
      "Test Insert Operations"
    ]
  },
  {
    "objectID": "test_insert.html#test-single-inserts",
    "href": "test_insert.html#test-single-inserts",
    "title": "Test Insert Operations",
    "section": "Test Single Inserts",
    "text": "Test Single Inserts\nHere we test insert()\n\nTest Cases for insert() Where Nothing Is Inserted\nTest that calling insert() without any parameters doesn‚Äôt change anything, and returns nothing\n\npeople.insert()\n\n{}\n\n\nTest None doesn‚Äôt change anything.\n\ncount = people.count\nassert people.insert(None) == {}\nassert people.count == count\n\nTest empty dict doesn‚Äôt change anything\n\ncount = people.count\nassert people.insert({}) == {}\nassert people.count == count\n\n\n# Test empty dataclass doesn't change anything\nPersonDC = people.dataclass()\ncount = people.count\nassert people.insert(PersonDC()) == {}\nassert people.count == count\n\n\n# Test empty class instance doesn't change anything\nclass EmptyPerson: pass\ncount = people.count\nassert people.insert(EmptyPerson()) == {}\nassert people.count == count\n\n\n\nSingle Insert Types\nTest insert with keyword argument. Result should be the inserted item.\n\nassert people.insert(name='Alice').name == 'Alice'\n\nTest insert with dataclass\n\nassert people.insert(People(name='Bobba')).name == 'Bobba'\n\nTest with regular class\n\nclass Student: pass\nstudent = Student()\nstudent.name = 'Charlo'\n\nassert people.insert(student).name == 'Charlo'\n\nVerify count is 3\n\nassert people.count == 3\n\n\n\nNone and Empty String Handling\nSQLite makes a clear distinction between NULL (represented as None in Python) and an empty string (‚Äô‚Äô). Unlike some popular Python ORMs, fastlite preserves this distinction because:\n\nNULL represents ‚Äúunknown‚Äù or ‚Äúmissing‚Äù data\nEmpty string represents ‚Äúknown to be empty‚Äù\n\nThese are semantically different concepts, and maintaining this distinction allows users to make appropriate queries (e.g.¬†WHERE name IS NULL vs WHERE name = ''). The fact that fastlite preserves this distinction in both directions (Python-&gt;SQLite and SQLite-&gt;Python) is good database design.\nTest inserting a record with name set to None\n\nresult = people.insert(name=None)\nassert result.name is None\n\nTest with empty string\n\nresult = people.insert(name='')\nassert result.name == ''\n\n\nassert people.get(pk_values=4).name == None\n\nRemember, get() is for getting single items. The following would not work here. pk_values can be a list only for tables with compound primary keys.\n# people.get(pk_values=[4,5])\n\n\nOther Cases\nTest with special characters\n\nassert people.insert(name='O\\'Connor').name == \"O'Connor\"\nassert people.insert(name='Jos√©').name == 'Jos√©'\n\nTest id auto-increment\n\np1 = people.insert(name='Test1')\np2 = people.insert(name='Test2') \nassert p2.id == p1.id + 1\n\nTest dict insert\n\nassert people.insert({'name': 'Dict Test'}).name == 'Dict Test'\n\nTest that extra fields raise apsw.SqlError\n\nfrom sqlite3 import OperationalError\n\n\ntry:\n    p = people.insert(name='Extra', age=25, title='Dr')\nexcept SQLError as e:\n    assert e.args[0] == 'table people has no column named age'",
    "crumbs": [
      "Test Insert Operations"
    ]
  },
  {
    "objectID": "test_insert.html#test-multiple-inserts",
    "href": "test_insert.html#test-multiple-inserts",
    "title": "Test Insert Operations",
    "section": "Test Multiple Inserts",
    "text": "Test Multiple Inserts\nHere we test insert_all()\n\nTest cases for insert_all() where nothing is changed\nTest empty list doesn‚Äôt change anything\n\ncount = people.count\npeople.insert_all([])\nassert people.count == count\n\nTest other empty iterables don‚Äôt change anything\n\ncount = people.count\npeople.insert_all(iter([]))  # empty iterator\npeople.insert_all(set())     # empty set\npeople.insert_all(tuple())   # empty tuple\nassert people.count == count\n\nTest that lists of None don‚Äôt change anything.\n\ncount = people.count\nassert people.insert_all([None, None]) == people\nassert people.result == []\nassert people.count == count\n\n\n\nTest cases for insert_all() where records are inserted\nTest that a list containing both None and a valid records only inserts the valid record.\n\ncount = people.count\npeople.insert_all([None, None, None, None, None, dict(name='Dermot')])\nassert people.count == count + 1\n\nTest list of dicts\n\ncount = people.count\ndata = [{'name': 'Bulk1'}, {'name': 'Bulk2'}, {'name': 'Bulk3'}]\npeople.insert_all(data)\nassert people.count == len(data) + count\n\nTest insert_all with a list of dataclass instances to insert\n\ncount = people.count\nPerson = people.dataclass()\ndata = [Person(name=f'DC{i}') for i in range(3)]\npeople.insert_all(data)\nassert people.count == count + 3\n\nTest list of regular class instances\n\ncount = people.count\nclass Student:\n    def __init__(self, name): self.name = name\nstudents = [Student(f'Student{i}') for i in range(3)]\npeople.insert_all(students)\nassert people.count == count + 3\n\n\n\nEdge Cases\nTest mixed types in list\n\ncount = people.count\nPerson = people.dataclass()\nmixed_data = [\n    {'name': 'Dict1'},\n    Person(name='DC1'),\n    Student('Student1')\n]\npeople.insert_all(mixed_data)\nassert people.count == count + 3\n\nTest None/empty strings in bulk insert\n\ncount = people.count\nnull_data = [\n    {'name': None},\n    {'name': ''},\n    {'name': 'Regular'}\n]\npeople.insert_all(null_data)\nassert people.count == count + 3\n\nTest with special characters in bulk\n\ncount = people.count\nspecial_data = [\n    {'name': \"O'Brien\"},\n    {'name': 'Jos√©'},\n    {'name': 'Âº†‰ºü'}\n]\nres = people.insert_all(special_data)\nassert people.count == count + 3\n\nTest error on invalid column\n\ntry:\n    people.insert_all([{'name': 'Valid'}, {'invalid_col': 'Bad'}])\nexcept SQLError as e:\n    assert 'no column named invalid_col' in str(e)",
    "crumbs": [
      "Test Insert Operations"
    ]
  },
  {
    "objectID": "test_update.html",
    "href": "test_update.html",
    "title": "Test Update Operations",
    "section": "",
    "text": "from fastlite import *\nfrom dataclasses import is_dataclass\n\nNote: Make sure to use fastlite‚Äôs database() here\n\ndb = database(':memory:')\n\n\nclass People: id: int; name: str\n\n\npeople = db.create(People, pk='id')",
    "crumbs": [
      "Test Update Operations"
    ]
  },
  {
    "objectID": "test_update.html#setup",
    "href": "test_update.html#setup",
    "title": "Test Update Operations",
    "section": "",
    "text": "from fastlite import *\nfrom dataclasses import is_dataclass\n\nNote: Make sure to use fastlite‚Äôs database() here\n\ndb = database(':memory:')\n\n\nclass People: id: int; name: str\n\n\npeople = db.create(People, pk='id')",
    "crumbs": [
      "Test Update Operations"
    ]
  },
  {
    "objectID": "test_update.html#test-single-updates",
    "href": "test_update.html#test-single-updates",
    "title": "Test Update Operations",
    "section": "Test Single Updates",
    "text": "Test Single Updates\nHere we test update()\n\nTest Cases for update() Where Nothing Is Updated\nTest that calling insert() without any parameters doesn‚Äôt change anything, and returns nothing\n\npeople.update()\n\n{}\n\n\nTest None doesn‚Äôt change anything.\n\ncount = people.count\nassert people.update(None) == {}\nassert people.count == count\n\nTest empty dict doesn‚Äôt change anything\n\ncount = people.count\nassert people.update({}) == {}\nassert people.count == count\n\n\n# Test empty dataclass doesn't change anything\nPersonDC = people.dataclass()\ncount = people.count\nassert people.update(PersonDC()) == {}\nassert people.count == count\n\n\n# Test empty class instance doesn't change anything\nclass EmptyPerson: pass\ncount = people.count\nassert people.update(EmptyPerson()) == {}\nassert people.count == count\n\n\n\nSingle Update Types\nTest update with dict. Result should include the Updated value\n\nperson = people.insert(name='Alice')\nadict = dict(id=person.id, name='Bob')\nassert people.update(adict).name == 'Bob'\nassert people[person.id].name == 'Bob'\n\nFetch record from database to confirm it has changed\n\nassert people[person.id].name == 'Bob'\n\nTest update with dataclass\n\ndc = People(id=person.id, name='Bobby')\nassert is_dataclass(dc) is True\nassert people.update(dc).name == 'Bobby'\nassert people[person.id].name == 'Bobby'\n\nTest with regular class\n\nclass Student: pass\nstudent = Student()\nstudent.name = 'Charlo'\nstudent.id = person.id\n\nassert people.update(student).name == 'Charlo'\nassert people[student.id].name == 'Charlo'\n\n\n\nNone and Empty String Handling\nSQLite makes a clear distinction between NULL (represented as None in Python) and an empty string (‚Äô‚Äô). Unlike some popular Python ORMs, fastlite preserves this distinction because:\n\nNULL represents ‚Äúunknown‚Äù or ‚Äúmissing‚Äù data\nEmpty string represents ‚Äúknown to be empty‚Äù\n\nThese are semantically different concepts, and maintaining this distinction allows users to make appropriate queries (e.g.¬†WHERE name IS NULL vs WHERE name = ''). The fact that fastlite preserves this distinction in both directions (Python-&gt;SQLite and SQLite-&gt;Python) is good database design.\nTest updating a record with name set to None\n\nresult = people.update(dict(id=person.id, name=None))\nassert result.name is None\nassert people[person.id].name == None\n\nTest with empty string\n\nresult = people.update(dict(id=person.id, name=''))\nassert result.name == ''\nassert people[person.id].name == ''\n\n\n\nOther Cases\nTest with special characters\n\nassert people.update(dict(id=person.id, name='O\\'Connor')).name == \"O'Connor\"\nassert people[person.id].name == \"O'Connor\"\nassert people.update(dict(id=person.id, name='Jos√©')).name == \"Jos√©\"\nassert people[person.id].name == \"Jos√©\"\n\nTest that extra fields raise fastlite.SqlError, which is a shim for apsw.SqlError:\n\ntry:\n    p = people.update(dict(id=person.id, name='Extra', age=25, title='Dr'))\nexcept SQLError as e:\n    assert e.args[0] == 'no such column: age'",
    "crumbs": [
      "Test Update Operations"
    ]
  }
]